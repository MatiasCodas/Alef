Shader "Custom/Alef" {

    Properties
    {
        [Toggle] Boolean_3CB1AC48("IsWall", Float) = 0
[Toggle] Boolean_E72D01AF("Outline", Float) = 0
[NoScaleOffset] Texture2D_B973E316("AlbedoMap", 2D) = "white" {}
Vector4_893EAFA("Tint", Vector) = (1,1,1,1)

    }
    SubShader
    {
        Tags{ "RenderPipeline" = "LightweightPipeline"}
        Tags
        {
            "RenderPipeline"="HDRenderPipeline"
            "RenderType"="Opaque"
            "Queue"="Geometry"
        }
        Pass
        {
        	Tags{"LightMode" = "LightweightForward"}

        	// Material options generated by graph

            Blend One Zero

            Cull Back

            ZTest LEqual

            ZWrite On

        	HLSLPROGRAM
            // Required to compile gles 2.0 with standard srp library
            #pragma prefer_hlslcc gles
            #pragma exclude_renderers d3d11_9x
            #pragma target 2.0

        	// -------------------------------------
            // Lightweight Pipeline keywords
            #pragma multi_compile _ _ADDITIONAL_LIGHTS
            #pragma multi_compile _ _VERTEX_LIGHTS
            #pragma multi_compile _ _MIXED_LIGHTING_SUBTRACTIVE
            #pragma multi_compile _ _SHADOWS_ENABLED
            #pragma multi_compile _ _LOCAL_SHADOWS_ENABLED
            #pragma multi_compile _ _SHADOWS_SOFT
            #pragma multi_compile _ _SHADOWS_CASCADE
            
        	// -------------------------------------
            // Unity defined keywords
            #pragma multi_compile _ DIRLIGHTMAP_COMBINED
            #pragma multi_compile _ LIGHTMAP_ON
            #pragma multi_compile_fog

            //--------------------------------------
            // GPU Instancing
            #pragma multi_compile_instancing

            #pragma vertex vert
        	#pragma fragment frag

        	// Defines generated by graph

        	#include "LWRP/ShaderLibrary/Core.hlsl"
        	#include "LWRP/ShaderLibrary/Lighting.hlsl"
        	#include "CoreRP/ShaderLibrary/Color.hlsl"
        	#include "CoreRP/ShaderLibrary/UnityInstancing.hlsl"
        	#include "ShaderGraphLibrary/Functions.hlsl"

            float Boolean_3CB1AC48;
            float Boolean_E72D01AF;
            TEXTURE2D(Texture2D_B973E316); SAMPLER(samplerTexture2D_B973E316);
            float4 Vector4_893EAFA;

            struct VertexDescriptionInputs
            {
                float3 ObjectSpacePosition;
            };

            struct SurfaceDescriptionInputs
            {
                float3 WorldSpaceNormal;
                float3 TangentSpaceNormal;
                float3 WorldSpaceViewDirection;
                float3 WorldSpacePosition;
                half4 uv0;
            };


            void Unity_FresnelEffect_float(float3 Normal, float3 ViewDir, float Power, out float Out)
            {
                Out = pow((1.0 - saturate(dot(normalize(Normal), normalize(ViewDir)))), Power);
            }

            void Unity_Step_float(float Edge, float In, out float Out)
            {
                Out = step(Edge, In);
            }

            void Unity_InvertColors_float(float In, float InvertColors, out float Out)
            {
                Out = abs(InvertColors - In);
            }

            void Unity_Branch_float(float Predicate, float True, float False, out float Out)
            {
                Out = lerp(False, True, Predicate);
            }

            void Unity_Multiply_float (float4 A, float4 B, out float4 Out)
            {
                Out = A * B;
            }

            void Unity_Add_float4(float4 A, float4 B, out float4 Out)
            {
                Out = A + B;
            }

            void CustomFunction_float(out float3 Direction, out float Attenuation, out float3 Color, float3 WorldPos)
            {
            			Light mainLight = GetMainLight();
            			Color = mainLight.color;
            			Direction = mainLight.direction;
            			float4 shadowCoord;
            			#ifdef _SHADOWS_ENABLED
                    	#if SHADOWS_SCREEN
            				float4 clipPos = TransformWorldToHClip(WorldPos);
                    		shadowCoord = ComputeShadowCoord(clipPos);
                    	#else
                    		shadowCoord = TransformWorldToShadowCoord(WorldPos);
                    	#endif
            			mainLight.attenuation = MainLightRealtimeShadowAttenuation(shadowCoord);
                    	#endif
            			Attenuation = mainLight.attenuation;
            		}

            void Unity_Normalize_float3(float3 In, out float3 Out)
            {
                Out = normalize(In);
            }

            void Unity_Add_float3(float3 A, float3 B, out float3 Out)
            {
                Out = A + B;
            }

            void Unity_DotProduct_float3(float3 A, float3 B, out float Out)
            {
                Out = dot(A, B);
            }

            void Unity_Maximum_float(float A, float B, out float Out)
            {
                Out = max(A, B);
            }

            void Unity_Power_float(float A, float B, out float Out)
            {
                Out = pow(A, B);
            }

            void Unity_Multiply_float (float3 A, float3 B, out float3 Out)
            {
                Out = A * B;
            }

            void Unity_Subtract_float3(float3 A, float3 B, out float3 Out)
            {
                Out = A - B;
            }

            void Unity_Clamp_float3(float3 In, float3 Min, float3 Max, out float3 Out)
            {
                Out = clamp(In, Min, Max);
            }

            void Unity_Branch_float3(float Predicate, float3 True, float3 False, out float3 Out)
            {
                Out = lerp(False, True, Predicate);
            }

            struct VertexDescription
            {
                float3 Position;
            };

            VertexDescription PopulateVertexData(VertexDescriptionInputs IN)
            {
                VertexDescription description = (VertexDescription)0;
                description.Position = IN.ObjectSpacePosition;
                return description;
            }

            struct SurfaceDescription
            {
                float3 Albedo;
                float3 Normal;
                float3 Emission;
                float Metallic;
                float Smoothness;
                float Occlusion;
                float Alpha;
                float AlphaClipThreshold;
            };

            SurfaceDescription PopulateSurfaceData(SurfaceDescriptionInputs IN)
            {
                SurfaceDescription surface = (SurfaceDescription)0;
                float _Property_3A3038AA_Out = Boolean_E72D01AF;
                float _FresnelEffect_D507FEC6_Out;
                Unity_FresnelEffect_float(IN.WorldSpaceNormal, IN.WorldSpaceViewDirection, 3, _FresnelEffect_D507FEC6_Out);
                float _Step_E806FE27_Out;
                Unity_Step_float(0.2, _FresnelEffect_D507FEC6_Out, _Step_E806FE27_Out);
                float _InvertColors_8179631F_Out;
                float _InvertColors_8179631F_InvertColors = float (1
                );Unity_InvertColors_float(_Step_E806FE27_Out, _InvertColors_8179631F_InvertColors, _InvertColors_8179631F_Out);

                float _Branch_99063418_Out;
                Unity_Branch_float(_Property_3A3038AA_Out, _InvertColors_8179631F_Out, 1, _Branch_99063418_Out);
                float _Property_54B4FA11_Out = Boolean_3CB1AC48;
                float4 _Property_E4BF192B_Out = Vector4_893EAFA;
                float4 _SampleTexture2D_83EC6802_RGBA = SAMPLE_TEXTURE2D(Texture2D_B973E316, samplerTexture2D_B973E316, IN.uv0.xy);
                float _SampleTexture2D_83EC6802_R = _SampleTexture2D_83EC6802_RGBA.r;
                float _SampleTexture2D_83EC6802_G = _SampleTexture2D_83EC6802_RGBA.g;
                float _SampleTexture2D_83EC6802_B = _SampleTexture2D_83EC6802_RGBA.b;
                float _SampleTexture2D_83EC6802_A = _SampleTexture2D_83EC6802_RGBA.a;
                float4 _Multiply_DD9DE5CF_Out;
                Unity_Multiply_float(_Property_E4BF192B_Out, _SampleTexture2D_83EC6802_RGBA, _Multiply_DD9DE5CF_Out);

                float4 _Add_C459A607_Out;
                Unity_Add_float4(_Multiply_DD9DE5CF_Out, float4(-0.2, -0.2, -0.2, -0.2), _Add_C459A607_Out);
                float3 _MainLight_97D59565_Direction;
                float _MainLight_97D59565_Attenuation;
                float3 _MainLight_97D59565_Color;
                CustomFunction_float(_MainLight_97D59565_Direction, _MainLight_97D59565_Attenuation, _MainLight_97D59565_Color, IN.WorldSpacePosition);
                float3 _Normalize_E7AEF074_Out;
                Unity_Normalize_float3(_MainLight_97D59565_Direction, _Normalize_E7AEF074_Out);
                float3 _Normalize_A9E21D4C_Out;
                Unity_Normalize_float3(IN.WorldSpaceViewDirection, _Normalize_A9E21D4C_Out);
                float3 _Add_680B5C7E_Out;
                Unity_Add_float3(_Normalize_E7AEF074_Out, _Normalize_A9E21D4C_Out, _Add_680B5C7E_Out);
                float3 _Normalize_9FCD559B_Out;
                Unity_Normalize_float3(_Add_680B5C7E_Out, _Normalize_9FCD559B_Out);
                float _DotProduct_50316BFD_Out;
                Unity_DotProduct_float3(IN.WorldSpaceNormal, _Normalize_9FCD559B_Out, _DotProduct_50316BFD_Out);
                float _Maximum_946EF7DF_Out;
                Unity_Maximum_float(0, _DotProduct_50316BFD_Out, _Maximum_946EF7DF_Out);
                float _Step_F8409A15_Out;
                Unity_Step_float(0.3, _Maximum_946EF7DF_Out, _Step_F8409A15_Out);
                float4 Color_66581E26 = IsGammaSpace() ? float4(0.4150943, 0.3831148, 0.3661445, 0) : float4(SRGBToLinear(float3(0.4150943, 0.3831148, 0.3661445)), 0);
                float4 _Multiply_D2E6DFDB_Out;
                Unity_Multiply_float((_Step_F8409A15_Out.xxxx), Color_66581E26, _Multiply_D2E6DFDB_Out);

                float Integer_FE609858 = 30;
                float _Power_FB473174_Out;
                Unity_Power_float(_Maximum_946EF7DF_Out, Integer_FE609858, _Power_FB473174_Out);
                float _Step_8DAA6427_Out;
                Unity_Step_float(0.3, _Power_FB473174_Out, _Step_8DAA6427_Out);
                float4 Color_3573A3DF = IsGammaSpace() ? float4(0.7264151, 0.7264151, 0.7264151, 0) : float4(SRGBToLinear(float3(0.7264151, 0.7264151, 0.7264151)), 0);
                float3 _Multiply_2AE5CC01_Out;
                Unity_Multiply_float((Color_3573A3DF.xyz), _MainLight_97D59565_Color, _Multiply_2AE5CC01_Out);

                float3 _Multiply_AECBBC2A_Out;
                Unity_Multiply_float((_Step_8DAA6427_Out.xxx), _Multiply_2AE5CC01_Out, _Multiply_AECBBC2A_Out);

                float3 _Subtract_9228611E_Out;
                Unity_Subtract_float3(_Multiply_AECBBC2A_Out, float3(0.5, 0.5, 0.5), _Subtract_9228611E_Out);
                float3 _Add_66B369AF_Out;
                Unity_Add_float3((_Multiply_D2E6DFDB_Out.xyz), _Subtract_9228611E_Out, _Add_66B369AF_Out);
                float3 _Clamp_E87C6B1E_Out;
                Unity_Clamp_float3(_Add_66B369AF_Out, float3(-0.2, -0.2, -0.2), float3(1, 1, 1), _Clamp_E87C6B1E_Out);
                float3 _Add_B819B6E4_Out;
                Unity_Add_float3((_Multiply_DD9DE5CF_Out.xyz), _Clamp_E87C6B1E_Out, _Add_B819B6E4_Out);
                float3 _Multiply_472441E9_Out;
                Unity_Multiply_float(_Add_B819B6E4_Out, float3(1, 1, 1), _Multiply_472441E9_Out);

                float3 _Branch_D619CAD7_Out;
                Unity_Branch_float3(_Property_54B4FA11_Out, (_Add_C459A607_Out.xyz), _Multiply_472441E9_Out, _Branch_D619CAD7_Out);
                float3 _Multiply_A3E12F0D_Out;
                Unity_Multiply_float((_Branch_99063418_Out.xxx), _Branch_D619CAD7_Out, _Multiply_A3E12F0D_Out);

                float3 _Multiply_D3CBE719_Out;
                Unity_Multiply_float(_Multiply_A3E12F0D_Out, float3(0.5, 0.5, 0.5), _Multiply_D3CBE719_Out);

                surface.Albedo = _Multiply_D3CBE719_Out;
                surface.Normal = IN.TangentSpaceNormal;
                surface.Emission = _Multiply_D3CBE719_Out;
                surface.Metallic = 0;
                surface.Smoothness = 10;
                surface.Occlusion = 1;
                surface.Alpha = 1;
                surface.AlphaClipThreshold = 0;
                return surface;
            }

            struct GraphVertexInput
            {
                float4 vertex : POSITION;
                float3 normal : NORMAL;
                float4 tangent : TANGENT;
                float4 texcoord0 : TEXCOORD0;
                float4 texcoord1 : TEXCOORD1;
                UNITY_VERTEX_INPUT_INSTANCE_ID
            };


        	struct GraphVertexOutput
            {
                float4 clipPos                : SV_POSITION;
                DECLARE_LIGHTMAP_OR_SH(lightmapUV, vertexSH, 0);
        		half4 fogFactorAndVertexLight : TEXCOORD1; // x: fogFactor, yzw: vertex light
            	float4 shadowCoord            : TEXCOORD2;

        		// Interpolators defined by graph
                float3 WorldSpacePosition : TEXCOORD3;
                float3 WorldSpaceNormal : TEXCOORD4;
                float3 WorldSpaceTangent : TEXCOORD5;
                float3 WorldSpaceBiTangent : TEXCOORD6;
                float3 WorldSpaceViewDirection : TEXCOORD7;
                half4 uv0 : TEXCOORD8;
                half4 uv1 : TEXCOORD9;

                UNITY_VERTEX_INPUT_INSTANCE_ID
            	UNITY_VERTEX_OUTPUT_STEREO
            };

            GraphVertexOutput vert (GraphVertexInput v)
        	{
        		GraphVertexOutput o = (GraphVertexOutput)0;
                UNITY_SETUP_INSTANCE_ID(v);
            	UNITY_TRANSFER_INSTANCE_ID(v, o);
        		UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);

        		// Vertex transformations performed by graph
                float3 WorldSpacePosition = mul(UNITY_MATRIX_M,v.vertex);
                float3 WorldSpaceNormal = normalize(mul(v.normal,(float3x3)UNITY_MATRIX_I_M));
                float3 WorldSpaceTangent = normalize(mul((float3x3)UNITY_MATRIX_M,v.tangent.xyz));
                float3 WorldSpaceBiTangent = cross(WorldSpaceNormal, WorldSpaceTangent.xyz) * v.tangent.w;
                float3 WorldSpaceViewDirection = _WorldSpaceCameraPos.xyz - mul(GetObjectToWorldMatrix(), float4(v.vertex.xyz, 1.0)).xyz;
                float4 uv0 = v.texcoord0;
                float4 uv1 = v.texcoord1;
                float3 ObjectSpacePosition = mul(UNITY_MATRIX_I_M,float4(WorldSpacePosition,1.0));

        		VertexDescriptionInputs vdi = (VertexDescriptionInputs)0;

        		// Vertex description inputs defined by graph
                vdi.ObjectSpacePosition = ObjectSpacePosition;

        	    VertexDescription vd = PopulateVertexData(vdi);
        		v.vertex.xyz = vd.Position;

        		// Vertex shader outputs defined by graph
                o.WorldSpacePosition = WorldSpacePosition;
                o.WorldSpaceNormal = WorldSpaceNormal;
                o.WorldSpaceTangent = WorldSpaceTangent;
                o.WorldSpaceBiTangent = WorldSpaceBiTangent;
                o.WorldSpaceViewDirection = WorldSpaceViewDirection;
                o.uv0 = uv0;
                o.uv1 = uv1;

        		float3 lwWNormal = TransformObjectToWorldNormal(v.normal);
        		float3 lwWorldPos = TransformObjectToWorld(v.vertex.xyz);
        		float4 clipPos = TransformWorldToHClip(lwWorldPos);

         		// We either sample GI from lightmap or SH.
        	    // Lightmap UV and vertex SH coefficients use the same interpolator ("float2 lightmapUV" for lightmap or "half3 vertexSH" for SH)
                // see DECLARE_LIGHTMAP_OR_SH macro.
        	    // The following funcions initialize the correct variable with correct data
        	    OUTPUT_LIGHTMAP_UV(v.texcoord1, unity_LightmapST, o.lightmapUV);
        	    OUTPUT_SH(lwWNormal, o.vertexSH);

        	    half3 vertexLight = VertexLighting(lwWorldPos, lwWNormal);
        	    half fogFactor = ComputeFogFactor(clipPos.z);
        	    o.fogFactorAndVertexLight = half4(fogFactor, vertexLight);
        	    o.clipPos = clipPos;

        	#ifdef _SHADOWS_ENABLED
        	#if SHADOWS_SCREEN
        		o.shadowCoord = ComputeShadowCoord(clipPos);
        	#else
        		o.shadowCoord = TransformWorldToShadowCoord(lwWorldPos);
        	#endif
        	#endif
        		return o;
        	}

        	half4 frag (GraphVertexOutput IN ) : SV_Target
            {
            	UNITY_SETUP_INSTANCE_ID(IN);

        		// Pixel transformations performed by graph
                float3 WorldSpacePosition = IN.WorldSpacePosition;
                float3 WorldSpaceNormal = IN.WorldSpaceNormal;
                float3 WorldSpaceTangent = IN.WorldSpaceTangent;
                float3 WorldSpaceBiTangent = IN.WorldSpaceBiTangent;
                float3 WorldSpaceViewDirection = IN.WorldSpaceViewDirection;
                float3x3 tangentSpaceTransform = float3x3(WorldSpaceTangent,WorldSpaceBiTangent,WorldSpaceNormal);
                float4 uv0 = IN.uv0;
                float4 uv1 = IN.uv1;
                float3 TangentSpaceNormal = mul(WorldSpaceNormal,(float3x3)tangentSpaceTransform);

                SurfaceDescriptionInputs surfaceInput = (SurfaceDescriptionInputs)0;

        		// Surface description inputs defined by graph
                surfaceInput.WorldSpaceNormal = WorldSpaceNormal;
                surfaceInput.TangentSpaceNormal = TangentSpaceNormal;
                surfaceInput.WorldSpaceViewDirection = WorldSpaceViewDirection;
                surfaceInput.WorldSpacePosition = WorldSpacePosition;
                surfaceInput.uv0 = uv0;

                SurfaceDescription surf = PopulateSurfaceData(surfaceInput);

        		float3 Albedo = float3(0.5, 0.5, 0.5);
        		float3 Specular = float3(0, 0, 0);
        		float Metallic = 1;
        		float3 Normal = float3(0, 0, 1);
        		float3 Emission = 0;
        		float Smoothness = 0.5;
        		float Occlusion = 1;
        		float Alpha = 1;
        		float AlphaClipThreshold = 0;

        		// Surface description remap performed by graph
                Albedo = surf.Albedo;
                Normal = surf.Normal;
                Emission = surf.Emission;
                Metallic = surf.Metallic;
                Smoothness = surf.Smoothness;
                Occlusion = surf.Occlusion;
                Alpha = surf.Alpha;
                AlphaClipThreshold = surf.AlphaClipThreshold;

        		InputData inputData;
        		inputData.positionWS = WorldSpacePosition;

        #ifdef _NORMALMAP
        	    inputData.normalWS = TangentToWorldNormal(Normal, WorldSpaceTangent, WorldSpaceBiTangent, WorldSpaceNormal);
        #else
            #if !SHADER_HINT_NICE_QUALITY
                inputData.normalWS = WorldSpaceNormal;
            #else
        	    inputData.normalWS = normalize(WorldSpaceNormal);
            #endif
        #endif

        #if !SHADER_HINT_NICE_QUALITY
        	    // viewDirection should be normalized here, but we avoid doing it as it's close enough and we save some ALU.
        	    inputData.viewDirectionWS = WorldSpaceViewDirection;
        #else
        	    inputData.viewDirectionWS = normalize(WorldSpaceViewDirection);
        #endif

        	    inputData.shadowCoord = IN.shadowCoord;

        	    inputData.fogCoord = IN.fogFactorAndVertexLight.x;
        	    inputData.vertexLighting = IN.fogFactorAndVertexLight.yzw;
        	    inputData.bakedGI = SAMPLE_GI(IN.lightmapUV, IN.vertexSH, inputData.normalWS);

        		half4 color = LightweightFragmentPBR(
        			inputData, 
        			Albedo, 
        			Metallic, 
        			Specular, 
        			Smoothness, 
        			Occlusion, 
        			Emission, 
        			Alpha);

        		// Computes fog factor per-vertex
            	ApplyFog(color.rgb, IN.fogFactorAndVertexLight.x);

        #if _AlphaClip
        		clip(Alpha - AlphaClipThreshold);
        #endif
        		return color;
            }

        	ENDHLSL
        }
        Pass
        {
        	Name "ShadowCaster"
            Tags{"LightMode" = "ShadowCaster"}

            ZWrite On ZTest LEqual

            // Material options generated by graph
            Cull Back

            HLSLPROGRAM
            // Required to compile gles 2.0 with standard srp library
            #pragma prefer_hlslcc gles
            #pragma exclude_renderers d3d11_9x
            #pragma target 2.0

            //--------------------------------------
            // GPU Instancing
            #pragma multi_compile_instancing

            #pragma vertex ShadowPassVertex
            #pragma fragment ShadowPassFragment

            // Defines generated by graph

            #include "LWRP/ShaderLibrary/Core.hlsl"
            #include "LWRP/ShaderLibrary/Lighting.hlsl"
            #include "ShaderGraphLibrary/Functions.hlsl"
            #include "CoreRP/ShaderLibrary/Color.hlsl"

            float Boolean_3CB1AC48;
            float Boolean_E72D01AF;
            TEXTURE2D(Texture2D_B973E316); SAMPLER(samplerTexture2D_B973E316);
            float4 Vector4_893EAFA;

            struct VertexDescriptionInputs
            {
                float3 ObjectSpacePosition;
            };


            struct VertexDescription
            {
                float3 Position;
            };

            VertexDescription PopulateVertexData(VertexDescriptionInputs IN)
            {
                VertexDescription description = (VertexDescription)0;
                description.Position = IN.ObjectSpacePosition;
                return description;
            }

            struct GraphVertexInput
            {
                float4 vertex : POSITION;
                float3 normal : NORMAL;
                float4 tangent : TANGENT;
                float4 texcoord1 : TEXCOORD1;
                UNITY_VERTEX_INPUT_INSTANCE_ID
            };


        	struct VertexOutput
        	{
        	    float2 uv           : TEXCOORD0;
        	    float4 clipPos      : SV_POSITION;
                UNITY_VERTEX_INPUT_INSTANCE_ID
                UNITY_VERTEX_OUTPUT_STEREO
        	};

            // x: global clip space bias, y: normal world space bias
            float4 _ShadowBias;
            float3 _LightDirection;

            VertexOutput ShadowPassVertex(GraphVertexInput v)
        	{
        	    VertexOutput o;
        	    UNITY_SETUP_INSTANCE_ID(v);
                UNITY_TRANSFER_INSTANCE_ID(v, o);
                UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);

                // Vertex transformations performed by graph
                float3 WorldSpacePosition = mul(UNITY_MATRIX_M,v.vertex);
                float3 WorldSpaceNormal = normalize(mul(v.normal,(float3x3)UNITY_MATRIX_I_M));
                float4 uv1 = v.texcoord1;
                float3 ObjectSpacePosition = mul(UNITY_MATRIX_I_M,float4(WorldSpacePosition,1.0));

        		VertexDescriptionInputs vdi = (VertexDescriptionInputs)0;

                // Vertex description inputs defined by graph
                vdi.ObjectSpacePosition = ObjectSpacePosition;

        	    VertexDescription vd = PopulateVertexData(vdi);
                v.vertex.xyz = vd.Position;

        	    o.uv = uv1;
        	    
        	    float3 positionWS = TransformObjectToWorld(v.vertex.xyz);
                float3 normalWS = TransformObjectToWorldDir(v.normal);

                float invNdotL = 1.0 - saturate(dot(_LightDirection, normalWS));
                float scale = invNdotL * _ShadowBias.y;

                // normal bias is negative since we want to apply an inset normal offset
                positionWS = normalWS * scale.xxx + positionWS;
                float4 clipPos = TransformWorldToHClip(positionWS);

                // _ShadowBias.x sign depens on if platform has reversed z buffer
                clipPos.z += _ShadowBias.x;

        	#if UNITY_REVERSED_Z
        	    clipPos.z = min(clipPos.z, clipPos.w * UNITY_NEAR_CLIP_VALUE);
        	#else
        	    clipPos.z = max(clipPos.z, clipPos.w * UNITY_NEAR_CLIP_VALUE);
        	#endif
                o.clipPos = clipPos;

        	    return o;
        	}

            half4 ShadowPassFragment(VertexOutput IN) : SV_TARGET
            {
                UNITY_SETUP_INSTANCE_ID(IN);
                return 0;
            }

            ENDHLSL
        }

        Pass
        {
        	Name "DepthOnly"
            Tags{"LightMode" = "DepthOnly"}

            ZWrite On
            ColorMask 0

            // Material options generated by graph
            Cull Back

            HLSLPROGRAM
            // Required to compile gles 2.0 with standard srp library
            #pragma prefer_hlslcc gles
            #pragma exclude_renderers d3d11_9x
            #pragma target 2.0

            //--------------------------------------
            // GPU Instancing
            #pragma multi_compile_instancing

            #pragma vertex vert
            #pragma fragment frag

            // Defines generated by graph

            #include "LWRP/ShaderLibrary/Core.hlsl"
            #include "LWRP/ShaderLibrary/Lighting.hlsl"
            #include "ShaderGraphLibrary/Functions.hlsl"
            #include "CoreRP/ShaderLibrary/Color.hlsl"

            float Boolean_3CB1AC48;
            float Boolean_E72D01AF;
            TEXTURE2D(Texture2D_B973E316); SAMPLER(samplerTexture2D_B973E316);
            float4 Vector4_893EAFA;

            struct VertexDescriptionInputs
            {
                float3 ObjectSpacePosition;
            };


            struct VertexDescription
            {
                float3 Position;
            };

            VertexDescription PopulateVertexData(VertexDescriptionInputs IN)
            {
                VertexDescription description = (VertexDescription)0;
                description.Position = IN.ObjectSpacePosition;
                return description;
            }

            struct GraphVertexInput
            {
                float4 vertex : POSITION;
                float3 normal : NORMAL;
                float4 tangent : TANGENT;
                float4 texcoord1 : TEXCOORD1;
                UNITY_VERTEX_INPUT_INSTANCE_ID
            };


        	struct VertexOutput
        	{
        	    float2 uv           : TEXCOORD0;
        	    float4 clipPos      : SV_POSITION;
                UNITY_VERTEX_INPUT_INSTANCE_ID
                UNITY_VERTEX_OUTPUT_STEREO
        	};

            VertexOutput vert(GraphVertexInput v)
            {
                VertexOutput o = (VertexOutput)0;
        	    UNITY_SETUP_INSTANCE_ID(v);
                UNITY_TRANSFER_INSTANCE_ID(v, o);
                UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);

        	    // Vertex transformations performed by graph
                float3 WorldSpacePosition = mul(UNITY_MATRIX_M,v.vertex);
                float3 WorldSpaceNormal = normalize(mul(v.normal,(float3x3)UNITY_MATRIX_I_M));
                float4 uv1 = v.texcoord1;
                float3 ObjectSpacePosition = mul(UNITY_MATRIX_I_M,float4(WorldSpacePosition,1.0));

        		VertexDescriptionInputs vdi = (VertexDescriptionInputs)0;

                // Vertex description inputs defined by graph
                vdi.ObjectSpacePosition = ObjectSpacePosition;

        	    VertexDescription vd = PopulateVertexData(vdi);
                v.vertex.xyz = vd.Position;

        	    o.uv = uv1;
        	    o.clipPos = TransformObjectToHClip(v.vertex.xyz);
        	    return o;
            }

            half4 frag(VertexOutput IN) : SV_TARGET
            {
                UNITY_SETUP_INSTANCE_ID(IN);
                return 0;
            }
            ENDHLSL
        }

        // This pass it not used during regular rendering, only for lightmap baking.
        Pass
        {
        	Name "Meta"
            Tags{"LightMode" = "Meta"}

            Cull Off

            HLSLPROGRAM
            // Required to compile gles 2.0 with standard srp library
            #pragma prefer_hlslcc gles
            #pragma exclude_renderers d3d11_9x
            #pragma target 2.0

            #pragma vertex LightweightVertexMeta
            #pragma fragment LightweightFragmentMeta

            #pragma shader_feature _SPECULAR_SETUP
            #pragma shader_feature _EMISSION
            #pragma shader_feature _METALLICSPECGLOSSMAP
            #pragma shader_feature _ _SMOOTHNESS_TEXTURE_ALBEDO_CHANNEL_A
            #pragma shader_feature EDITOR_VISUALIZATION

            #pragma shader_feature _SPECGLOSSMAP

            #include "LWRP/ShaderLibrary/InputSurfacePBR.hlsl"
            #include "LWRP/ShaderLibrary/LightweightPassMetaPBR.hlsl"
            ENDHLSL
        }
    }
    FallBack "Hidden/InternalErrorShader"
}
